from __future__ import annotations

import os
import re
from datetime import datetime
from pathlib import Path
from typing import List, Optional, Tuple

from markdown_pdf import MarkdownPdf, Section


# ---------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------
def _sanitize_filename(text: str) -> str:
    """Remove or replace unsafe characters for filenames."""
    return re.sub(r"[^\w\-_\. ]", "_", text).strip()[:50]


def _format_question(q: str, idx: int) -> str:
    """Clean up user-supplied questions and add consistent numbering."""
    q = str(q).strip()
    if q.endswith("?"):
        q = q[:-1].rstrip() + "?"  # tidy up punctuation
    return f"{idx}. {q}"


# ---------------------------------------------------------------------
# Main factory
# ---------------------------------------------------------------------
def create_dpp_pdf(
    topic_name: str,
    questions: List[str],
    total_q: int,
    instructions: str,
    *,
    output_dir: str = "dpp_pdfs",
    include_answer_key: bool = False,
    answer_key: Optional[List[str]] = None,
    accent_color: str = "#3b82f6",  # Tailwind blue-500
    footer_text: str = "Generated by DPPify",
) -> str:
    
    # --- Validation -------------------------------------------------
    if not topic_name or not isinstance(topic_name, str):
        raise ValueError("topic_name must be a non-empty string")
    if not isinstance(questions, list):
        raise ValueError("questions must be a list")
    if not isinstance(instructions, str):
        raise ValueError("instructions must be a string")
    if total_q < 1:
        raise ValueError("total_q must be >= 1")

    # Slice or pad
    questions = questions[:total_q]
    if len(questions) < total_q:
        questions += [""] * (total_q - len(questions))
    questions = [q for q in questions if q]  # drop empties

    # --- Paths ------------------------------------------------------
    out_path = Path(output_dir).resolve()
    out_path.mkdir(parents=True, exist_ok=True)

    safe_topic = _sanitize_filename(topic_name)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    pdf_path = out_path / f"DPP_{safe_topic}_{timestamp}.pdf"

    # --- Markdown content ------------------------------------------
    md_lines = [
        f'<style>\n'
        f'  body {{ font-family: "Inter", sans-serif; color: #111827; }}\n'
        f'  h1 {{ color: {accent_color}; border-bottom: 2px solid {accent_color}; }}\n'
        f'  h2 {{ color: #374151; }}\n'
        f'  .footer {{ text-align: center; font-size: 0.8em; color: #6b7280; margin-top: 2rem; }}\n'
        f'</style>\n',
        "",
        "# üìö Daily Practice Problems",
        "",
        f"## Topic: **{topic_name}**",
        "",
        f"*Date:* {datetime.now():%B %d, %Y}",
        "",
        "---",
        "",
        "### üìù Instructions",
        "",
        instructions,
        "",
        "---",
        "",
        "## Questions",
        "",
    ]

    # Questions
    for idx, q in enumerate(questions, start=1):
        md_lines.append(_format_question(q, idx))
        md_lines.append("")

    # Optional answer key
    if include_answer_key:
        md_lines += ["", "---", "", "## ‚úÖ Answer Key", ""]
        if answer_key is None:
            answer_key = ["[Answer]"] * len(questions)
        if len(answer_key) != len(questions):
            raise ValueError("answer_key length must match questions displayed")

        for idx, ans in enumerate(answer_key, start=1):
            md_lines.append(f"{idx}. {ans}")
        md_lines.append("")

    # Footer
    md_lines += [
        "",
        "---",
        f'<div class="footer">{footer_text} ‚Ä¢ {datetime.now():%Y-%m-%d %H:%M:%S}</div>',
    ]

    md_content = "\n".join(md_lines)

    # --- PDF generation --------------------------------------------
    try:
        pdf = MarkdownPdf(toc_level=0)
        pdf.add_section(Section(md_content))
        pdf.save(str(pdf_path))

        if not pdf_path.exists():
            raise RuntimeError("PDF saving silently failed")

        return str(pdf_path)

    except Exception as e:
        raise RuntimeError(f"Failed to create PDF: {e}") from e
